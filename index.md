What software engineering means to me:
Software engineering to me means a way for computer scientists and developers to have a chance to create something for others
that involves a bit of creativity as well as some logical thinking. It involves a lot of problem solving and to me 
that seems to be something that will fun but challenging to do at the same time. 

Why are you taking software engineering and what do you hope to take out of the class?
I'm taking this class because I'm a computer science major, but I'm also interested 
in software and want to become a better programmer. 
I hope this class will help me with any weaknesses that I have when it comes to coding. 

After reading the first chapter from the book A Pragmatic Programmer, it was interesting to see how the author gives you tips and techniques in which you can be a better programmer, such as taking resposibility, or showing how to be better at coding by trying not to repeat code you've already written. Another thing that I thought was interesting was the paragraph about software entromy; when disorder increases in software and programmers call it "software rot". I'd had never heard about this. Overall, I think this chapter is a good introduction to this course because it starts by advising what to do and what not to do when you start to program.

After reading chapter 2, it was interesting to learn about the term orthogonality and how it is important in 
in terms of organizng your code and keeping track of the fact that if it has minimal duplication. I also agree with using the 
"DRY" method in order to not repeat the code you've already put in, so that you don't have to change other things if you change one. It was also interesting to see the many things that tie in with orthogonality, such as it's positives of having reduced risks, design, and libraries. Another advantage of it is that testing your code becomes easier. However, one thing that confused me in the chapter was prototypes. Overall, I think that it was a good chapter to read.

After reading chapter 4, it was interesting to learn about DBC, or Design by Contract which
is a software that helps with code correctness. I never heard abour this before so it was interesting to see how and what is is used for. It was also interesting to read about assertive programming. I was surprised to 
see that Exceptions were in this chapter, since I've used them before in my previous projects. It kind of 
refreshed them in my head, and how they are used.

I think that Chapter 7 does a good job of explaining where to start when we have a big project,like the one we're doing in class now. I thought it was interesting how it shows you how to start looking for requirements, and what you need to start working on the project, (which is the hardest part for me, because I usually don't know where to start), so this chapter was helpful to me on that part. Another thing I liked was how it talked about how we usually end up procrastinating as programmers, and that the good way of knowing if you are is by prototyping. I think that the chapter was also good in regards of explaining techniques that help you with any puzzels you or your group members encounter while working on the project.

It was interesting to read about the 12 factors, and the process of building a web app. As I was reading throughout each one, most of them did make sense, however, it did start to get confusing as I got towards the end of the list. I could recognize some of the terms from class, such as dependencies, config, backing services, etc. Some of the newer factors that I was unfamilar with was port-binding, concurrency, div/prod parity, or treating logs as event streams. Additionally, I could see why we would need these 12 factors as we start to work on our project, since we are basically building a web app, that is used for reservation. 
